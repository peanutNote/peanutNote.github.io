<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千叶笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-05T01:28:50.348Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>易雄</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FlexLib初体验</title>
    <link href="http://yoursite.com/2018/05/05/FlexLib%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2018/05/05/FlexLib初体验/</id>
    <published>2018-05-05T01:28:03.000Z</published>
    <updated>2018-05-05T01:28:50.348Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS下原生webView与js相互调用总结</title>
    <link href="http://yoursite.com/2018/05/05/iOS%E4%B8%8B%E5%8E%9F%E7%94%9FwebView%E4%B8%8EJS%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/05/iOS下原生webView与JS相互调用总结/</id>
    <published>2018-05-05T01:28:03.000Z</published>
    <updated>2018-05-05T01:29:55.686Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目转型，很多需求转为使用H5开发完成后再由app调用，这样一来app需要做的最多的事情就是解决js与原生oc相互调用的问题，例如照片、通讯录选择等，下面就将最近一段时间的研究成果记录下来。</p><h3 id="UIWebView篇"><a href="#UIWebView篇" class="headerlink" title="UIWebView篇"></a>UIWebView篇</h3><p>1、UIWebView自带方法：js-&gt;oc，通过拦截网络请求判断约定好的协议实现交互；oc-&gt;js，通过UIWebView方法<code>stringByEvaluatingJavaScriptFromString:</code>实现。  </p><p>我们先准备一个简单的html文件用作测试使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;UIWebView方式1&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var AppJSBridge = new Object();</span><br><span class="line">    function helloworld()</span><br><span class="line">    &#123;</span><br><span class="line">        alert(&quot;这里是网页弹窗&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;a href=&quot;success://xxx/xxx?xxx&amp;xxx&quot;&gt;hello world&lt;/a&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接着我们用创建的UIWebView加载这个html，在代理方法<code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</code>中写判断逻辑即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *requestString = [[request URL] absoluteString];</span><br><span class="line">if ([requestString hasPrefix:@&quot;success&quot;]) &#123;</span><br><span class="line">    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;这里是OC原生弹窗&quot; delegate:self cancelButtonTitle:@&quot;我知道了&quot; otherButtonTitles:nil];</span><br><span class="line">    [alertView show];</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">return YES;</span><br></pre></td></tr></table></figure><p>oc回调js方法的代码在UIAlertView代理方法中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123;</span><br><span class="line">     [self.webView stringByEvaluatingJavaScriptFromString:@&quot;helloworld();&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、通过<em>JavaScriptCore</em>框架实现<br>JavaScriptCore在oc与js交互中具有很强大的功能，这里只介绍通过UIWebView使用JavaScriptCore的部分，更多JavaScriptCore内容需要学者自行补充。</p><p>同样我们需要准备一个简单的html文件用作测试使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;UIWebView方式2&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var AppJSBridge = new Object();</span><br><span class="line">    function helloworld(a, b, c)</span><br><span class="line">    &#123;</span><br><span class="line">        window.AppJSBridge.hello(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;button onclick=&quot;helloworld(参数1，参数2，参数3)&quot;&gt;helloworld&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接着我们需要在webView加载完成后获取JSContext对象，用以动态绑定和调用JS方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span><br><span class="line">    JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">    </span><br><span class="line">    JSValue *appJSBridge = context[@&quot;AppJSBridge&quot;];</span><br><span class="line">    appJSBridge[@&quot;hello&quot;] = ^() &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;这里是OC原生弹窗&quot; delegate:self cancelButtonTitle:@&quot;我知道了&quot; otherButtonTitles:nil];</span><br><span class="line">            [alertView show];</span><br><span class="line">        &#125;);</span><br><span class="line">        NSArray *args = [JSContext currentArguments];</span><br><span class="line">        for (JSValue *jsVal in args) &#123;</span><br><span class="line">            NSLog(@&quot;%@&quot;, jsVal.toString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]</code>方式从webView中获取JSContext对象，然后通过<code>context[@&quot;AppJSBridge&quot;]</code>获取js中的<em>AppJSBridge</em>对象，接着通过<code>appJSBridge[@&quot;hello&quot;]</code>赋值一个oc的block代码块来绑定方法实现。经过测试该block为异步调用，如果在里面需要刷新oc界面则需要将代码放到主线程中执行，同时需要注意block的循环引用。<code>[JSContext currentArguments]</code>方法可以获取调用中所传参数。</p><p>oc回调js的方式，在oc中需要添加一个按钮，按钮方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)action:(UIButton *)sender &#123;</span><br><span class="line">    JSValue *callBack = context[@&quot;helloworld&quot;];</span><br><span class="line">    [callBack callWithArguments:@[@&quot;参数1&quot;, @&quot;参数2&quot;, @&quot;参数3&quot;]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中context需要为<code>webViewDidFinishLoad</code>中获取的JSContext对象</p><p>3、通过第三方<a href="https://github.com/dukeland/EasyJSWebView" target="_blank" rel="noopener">EasyJSWebView</a>实现<br>EasyJSWebView实现原理其实跟第一种方法一样，通过注入js代码在js方法中添加特定“假”请求，然后在代理方法中抓去该请求调用oc对象方法。虽然EasyJSWebView已经很久没有人维护了且不支持ARC，但是我们只需要稍作修改还是可以实现的，并且其实现方法可以借鉴。</p><h3 id="WKWebView篇"><a href="#WKWebView篇" class="headerlink" title="WKWebView篇"></a>WKWebView篇</h3><p>相校与UIWebView来说，WKWebView的功能就更加丰富一些，可以不用借助<em>JavaScriptCore</em>也可以实现类似的方法互调，至于两者其他不同之处这里不做讨论</p><p>这里准备的html测试文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;WkWebView方式&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var AppJSBridge = new Object();</span><br><span class="line">    function helloworld()</span><br><span class="line">    &#123;</span><br><span class="line">        //前端需要用 window.webkit.messageHandlers.注册的方法名.postMessage(&#123;body:传输的数据&#125; 来给native发送消息</span><br><span class="line">        window.webkit.messageHandlers.hello.postMessage(&#123;title:&apos;测试分享的标题&apos;,content:&apos;测试分享的内容&apos;,url:&apos;http://www.baidu.com&apos;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;button onclick=&quot;helloworld()&quot;&gt;helloworld&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接着WKWebView的创建方法中我们需要事先注册js中指定的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WKUserContentController *content = [[WKUserContentController alloc] init];</span><br><span class="line">WebScriptMessageHandler *handler = [[WebScriptMessageHandler alloc] init];</span><br><span class="line">[content addScriptMessageHandler:handler name:@&quot;hello&quot;];</span><br><span class="line">    </span><br><span class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">config.userContentController = content;</span><br><span class="line">    </span><br><span class="line">WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];</span><br><span class="line">webView.navigationDelegate = self;</span><br><span class="line">webView.UIDelegate = self;</span><br><span class="line">[self.view addSubview:_webView];</span><br></pre></td></tr></table></figure><p>其中<em>handler</em>对象需要实现一个协议<code>WKScriptMessageHandler</code>才可以作为<em>content</em>方法<code>addScriptMessageHandler:name:</code>的参数，该协议中有个必须实现的方法<code>- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message</code>，后面的name即为js中相同的方法名，当js中执行<code>window.webkit.messageHandlers.hello.postMessage({title:&#39;测试分享的标题&#39;,content:&#39;测试分享的内容&#39;,url:&#39;http://www.baidu.com&#39;});</code>代码时就会在oc回调该代理方法，并返回参数（这里需要注意不可以用self实现WKScriptMessageHandler然后作为handle对象，这样会导致循环引用）。</p><p>oc回调js方法与UIWebView类似，不同之处时WKWebView是一个异步调用不会阻塞主线程，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.webView evaluateJavaScript:@&quot;say()&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,result);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>附加：WKWebView可以监听一些属性获取js数据，下面展示在导航栏动态展示web的title实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[self.webView addObserver:self forKeyPath:@&quot;title&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;title&quot;]) &#123;</span><br><span class="line">        if (object == self.webView) &#123;</span><br><span class="line">            if(self.navigationController)</span><br><span class="line">                self.navigationItem.title = self.webView.title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WKWebView代码方法比较多，下面也就简单介绍一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKNavigationDelegate</span><br><span class="line"></span><br><span class="line">// 页面开始加载时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation &#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当内容开始返回时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面加载完成之后调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面加载失败时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error &#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接收到服务器跳转请求之后调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation &#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在收到响应后，决定是否跳转</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;   </span><br><span class="line">    NSLog(@&quot;%@&quot;,navigationResponse.response.URL.absoluteString);</span><br><span class="line">    //允许跳转</span><br><span class="line">    decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line">    //不允许跳转</span><br><span class="line">    //decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line">&#125;</span><br><span class="line">// 在发送请求之前，决定是否跳转</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,navigationAction.request.URL.absoluteString);</span><br><span class="line">    //允许跳转</span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    //不允许跳转</span><br><span class="line">    //decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - WKUIDelegate</span><br><span class="line">// 创建一个新的WebView</span><br><span class="line">- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">// 输入框</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler &#123;</span><br><span class="line">    completionHandler(@&quot;http&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 确认框</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler &#123;</span><br><span class="line">    completionHandler(YES);</span><br><span class="line">&#125;</span><br><span class="line">// 警告框</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">    MyLog(@&quot;%@&quot;,message);</span><br><span class="line">    completionHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目转型，很多需求转为使用H5开发完成后再由app调用，这样一来app需要做的最多的事情就是解决js与原生oc相互调用的问题，例如照片、通讯录选择等，下面就将最近一段时间的研究成果记录下来。&lt;/p&gt;
&lt;h3 id=&quot;UIWebView篇&quot;&gt;&lt;a href=&quot;#UIWeb
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS本地化</title>
    <link href="http://yoursite.com/2016/04/19/iOS%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    <id>http://yoursite.com/2016/04/19/iOS本地化/</id>
    <published>2016-04-19T06:37:40.000Z</published>
    <updated>2018-04-08T08:34:29.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QYLocalization"><a href="#QYLocalization" class="headerlink" title="QYLocalization"></a>QYLocalization</h2><p>最近接触到iOS应用本地化的相关使用，于是花了点时间研究了一下，下面把成果分享给大家。</p><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><ul><li>使用本地化功能，可以轻松地将应用程序翻译成多种语言，甚至可以翻译成同一语言的多种方言</li><li>如果要添加本地化功能，需要为每种支持的语言创建一个子目录，称为”本地化文件夹”，通常使用.lproj作为拓展名</li><li>当本地化的应用程序需要载入某一资源时，如图像、属性列表、nib文件，应用程序会检查用户的语言和地区，并查找相匹配的本地化文件夹。如果找到了相应的文件夹，就会载入这个文件夹中的资源</li><li>当前项目环境为Xcode7.3、iOS9.3，涉及的代码可以去我们github上下载：<span style="color: #0000ff;"><a href="https://github.com/peanutNote/QYLocalization.git" target="_blank" rel="noopener">https://github.com/peanutNote/QYLocalization.git</a> </span></li><li>为了节约时间本文大致基于<a href="http://blog.csdn.net/q199109106q/article/details/8564615" target="_blank" rel="noopener">李明杰老师的博客</a>进行写作</li></ul><h3 id="二、创建项目"><a href="#二、创建项目" class="headerlink" title="二、创建项目"></a>二、创建项目</h3><p>工程目录结构</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418201256929-174214643.png" alt="image"></p><p>运行效果图(因为没有使用本地化功能，所以不管用户选择什么语言环境，运行的效果都是一样的)</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418202058820-1508814125.png" alt="image"><br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418202134054-914477904.png" alt="image"><br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418202149554-232771392.png" alt="image"></p><p>现在想在中文语言环境下，换另一套实现，其中包括：</p><ul><li>更改storyboard文件中的文字（nib本地化,storyboard也是nib的一种</li><li>更改登录按钮下面的图片（图片本地化）   </li><li>更改对话框中的文字(Tip和Ok)（字符串本地化）   </li><li>更改应用名称（应用名称本地化，即本地化Info.plist文件） </li></ul><h3 id="三、本地化前的准备"><a href="#三、本地化前的准备" class="headerlink" title="三、本地化前的准备"></a>三、本地化前的准备</h3><p>其实就是先创建好中文的本地化文件夹（zh-Hans.lproj），让应用程序支持中文语言环境</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418202225804-1224327948.png" alt="image"> </p><p>其中Base.lproj就是指的勾选的本地化，也就是说我们项目创建默认使用的是Base的本地化。这也是为什么每次创建项目Main.storyboard会在一个Base.lproj的文件夹中的原因。同时鼠标指的是系统默认创建的一个英文本地化配置(里面有两个文件正好跟Base.lproj中的对应，目前可以理解Base也是英文的一种本地化)。这里为了不影响说明我们去掉这个勾选，只用中文和英文本地化来进行说明。当我去掉勾时会删除Main.storyboard和LaunchScreen.stroyboard，因此我们需要先在英文换件中添加这两个文件然后再去掉Base，具体办法就是选中Main.storyboard,勾选下图的English这两个文件就会拷贝一份到en.lproj中。</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418201538476-1545911645.png" alt="image"></p><p>我们来看此时的项目文件结构</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160419112705866-1631692328.png" alt=""></p><p>进入正题：因为英文Localization系统已经帮我们创建好了，我们在这里只需要创建中文Localization即可</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418202335132-261429544.png" alt=""></p><p>选择Finish后我们的项目文件结果为：</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418202823288-1344437197.png" alt=""></p><p>zh-Hans.lproj文件夹已经为我们创建好了，与en.lproj文件夹一样包含一个Main.storyboard表示在中文环境会启用这里面的资源。这里有的同学可能在zh-Hans中生成的不是Main.storyboard而是Main.strings,这是因为你没有去掉Base这个本地化(也就是上文中的勾)，不过这时候也可以自己选择</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418203407101-752360795.png" alt=""></p><p>至于这里的Main.strings文件也是关于storyboard本地化的一种方法。需要我们先在nib中添加好控件弄好布局以后在执行本地化，然后Main.strings中就会生成类似字符串本地化(后面会介绍，因为这种方法只能修改控件的title，所以我这里没有使用这个来说明)一样的文件,修改对应的地方就可以修改storyboard中的控件title了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Class = "UILabel"; text = "Password"; ObjectID = "6Jw-lK-yZp"; */</span></span><br><span class="line"><span class="string">"6Jw-lK-yZp.text"</span> = <span class="string">"Password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class = "UIButton"; normalTitle = "Login"; ObjectID = "M8g-w0-oLf"; */</span></span><br><span class="line"><span class="string">"M8g-w0-oLf.normalTitle"</span> = <span class="string">"Login"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class = "UILabel"; text = "UserName"; ObjectID = "io8-3O-gpY"; */</span></span><br><span class="line"><span class="string">"io8-3O-gpY.text"</span> = <span class="string">"UserName"</span>;</span><br></pre></td></tr></table></figure><p>同时Xcode中的Main.storyboard左边会出现一个三角，展开可以发现分别都有2个版本的文件。到此我们的项目就支持英文和中文环境了，本地化准备完毕</p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418203259366-1538073848.png" alt=""></p><h3 id="四、nib文件的本地化"><a href="#四、nib文件的本地化" class="headerlink" title="四、nib文件的本地化"></a>四、nib文件的本地化</h3><p>打开Main.storyboard(Simplified)文件，修改里面的文字信息(这里不修改图片)<br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418203904398-1855906145.png" alt=""> </p><h3 id="五、应用程序名称本地化-Info-plist本地化"><a href="#五、应用程序名称本地化-Info-plist本地化" class="headerlink" title="五、应用程序名称本地化(Info.plist本地化)"></a>五、应用程序名称本地化(Info.plist本地化)</h3><p>知识背景：Info.plist中有个叫CFBundleDisplayName的key决定了应用程序的名称  </p><p>1.为Info.plist添加一个key-value，让应用程序支持名称本地化，Info.plist就会去InfoPlist.strings加载CFBundleDisplayName对应的字符串,（这里需要注意不能直接本地化Info.plist，因为这样做之后Info.plist文件会存在各自的本地化文件夹中(像en.lproj)中，这样系统会报Info.plist文件不存在的问题，虽然可以去指定Info.plist文件的位置，但是这样就不能实现本地化的目的了，所以需要用到InfoPlist.strings文件）。<br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418211850835-2136615719.png" alt=""> </p><p>用这种方法分别为英文和中文本地化添加InfoPlist.strings文件并且在Info.plst中添加Application has localized display name字段，赋值为YES </p><p><img src="http://img.my.csdn.net/uploads/201302/02/1359770541_8270.png" alt=""> </p><p>在对应的InfoPlist.strings文件中添加各自的应用名 InfoPlist.strings(English):</p><p><code>CFBundleDisplayName=&quot;Localization&quot;;</code></p><p>在InfoPlist.strings(Simplifid):</p><p><code>CFBundleDisplayName=&quot;本地化&quot;;</code></p><h3 id="六、图片本地化"><a href="#六、图片本地化" class="headerlink" title="六、图片本地化"></a>六、图片本地化</h3><p>1.直接拖拽到项目的图片本地化(这里演示本地化home.png，nib文件中登录按钮下面的房子图片) 用上面添加InfoPlist.strings的方法添加该图片的本地化，分别为英文和中文环境添加home.png文件 </p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418212858913-1447783158.png" alt=""></p><p>查看下项目文件中home.png的情况 </p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418213135726-220025052.png" alt=""> </p><p>在代码中使用<code>[UIImage imageNamed:@&quot;home.png&quot;];</code>  即可   </p><p><span style="color: #ff0000; background-color: #ffffff;">注意：本地化完图片文件，记得Clean一下项目，而且最好先删除应用程序，再重新安装</span> </p><p>2.使用Assets.xcassets或者Images.xcassets管理图片本地化  因为iOS暂不支持.xcassets的本地化，所以这里需要结合字符串的本地化来处理(这里也放在后面介绍) </p><h3 id="七、字符串的本地化"><a href="#七、字符串的本地化" class="headerlink" title="七、字符串的本地化"></a>七、字符串的本地化</h3><p>1.创建一个字符串资源文件 文件名最好是Localizable.strings，如果使用其他文件名，使用字符串时的调用会有些区别<br>2.依旧按照上面的方法为Localizable.strings添加多语言支持<br>3.在Localizable.strings(English)文件加入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tip=<span class="string">"Tip"</span>;</span><br><span class="line"> </span><br><span class="line">Ok=<span class="string">"Ok"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="string">"Please input your userName"</span>=<span class="string">"Please input your userName"</span>;</span><br></pre></td></tr></table></figure><p>4.在Localizable.strings(Chinese)文件加入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Tip=<span class="string">"提示"</span>;</span><br><span class="line"> </span><br><span class="line">Ok=<span class="string">"好的"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="string">"Please input your userName"</span>=<span class="string">"请输入用户名"</span>;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>在代码中使用<span class="built_in">NSLocalizedString</span>(key, comment)来读取本地化字符串，key是Localizable.strings文件中等号左边的字符串，comment纯粹是注释。同时上文中提到的.xcassets本地化也需要用到这个。首先添加各自的图片并命名如：image1，image2，本地化一个字符串imageName用作图片的名字，然后在各自的Localizable.strings中对应到各自的实际图片名称即可。  </span><br><span class="line"> </span><br><span class="line"><span class="number">6.</span>在Localizable.strings(English)文件加入：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="string">"imageName"</span> = <span class="string">"image1"</span>;</span><br></pre></td></tr></table></figure><p>7.在Localizable.strings(Chinese)文件加入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"imageName"</span> = <span class="string">"image2"</span>;</span><br></pre></td></tr></table></figure><p><span style="color: #ff0000; background-color: #ffffff;">如果没有对字符串进行本地化 或者 找不到key对应的值，NSLocalizedString将直接返回key这个字符串</span>  </p><p>注意：如果你的字符串资源文件名不是Localizable.strings，如qy.strings，那么你就得使用NSLocalizedStringFromTable()来读取本地化字符串：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Tip"</span>, <span class="string">@"qy"</span>, <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure><p>补充：生成字符串资源文件的另一种方式(通过终端命令genstrings，可以自行补充)</p><p>1.首先添加获取字符串的代码，比如在ViewController.m。(其实这里就是方便我们不用针对每一个需要本地化字符串的地方都去上面Localizable.strings文件中一一添加，我们只需要使用NSLocalizedString取字符串然后用genstrings命令就可以帮我们完善Localizable.strings文件啦)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *tip = <span class="built_in">NSLocalizedString</span>(<span class="string">@"Tip"</span>, <span class="string">@"dialog title"</span>); </span><br><span class="line"><span class="built_in">NSString</span> *ok = <span class="built_in">NSLocalizedString</span>(<span class="string">@"Ok"</span>, <span class="string">@"dialog button"</span>);</span><br></pre></td></tr></table></figure><p>2.打开终端，cd到项目文件夹下(包含en.lproj和zh-Hans.lproj，否则会报错couldn’t connect to output directory xx.lproj)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name <span class="string">"*.m"</span> -print0 | xargs <span class="number">-0</span> genstrings -o en.lproj <span class="comment">// 注意*.m旁边的引号，这个不可缺少，网上有很多这种命令是没有加引号的，这样执行会报错xx.m: unknown primary or operator</span></span><br></pre></td></tr></table></figure><p>如果使用NSLocalizedStringFromTable(key, tbl, comment)来获取字符串，资源文件会以tbl参数作为文件名，比如</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *tip = <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Tip"</span>, <span class="string">@"qy"</span>, <span class="string">@"dialog title"</span>);  </span><br><span class="line"><span class="built_in">NSString</span> *ok = <span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Ok"</span>, <span class="string">@"qy"</span>, <span class="string">@"dialog button"</span>);</span><br></pre></td></tr></table></figure><p>生成的资源文件为：qy.strings</p><p>4.将资源文件导入项目即可，然后打开资源文件，可以发现已经生成了key和comment </p><h3 id="八、其他文件的本地化"><a href="#八、其他文件的本地化" class="headerlink" title="八、其他文件的本地化"></a>八、其他文件的本地化</h3><p>跟六中图片本地化的原理是一样的，重复六中的每个步骤即可 </p><h3 id="九、最终效果演示"><a href="#九、最终效果演示" class="headerlink" title="九、最终效果演示"></a>九、最终效果演示</h3><p>1.英文环境下  </p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418221518179-1497265294.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418221812491-828679484.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418221819913-1076150726.png" alt=""></p><p>2.中文环境下   </p><p><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418221633663-1786821289.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418221702366-1999391314.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/685098/201604/685098-20160418221709866-1016484201.png" alt=""><br>最后给大家推荐一篇不错的本地化<a href="https://www.raywenderlich.com/64401/internationalization-tutorial-for-ios-2014" target="_blank" rel="noopener">博客</a>，提供给大家参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QYLocalization&quot;&gt;&lt;a href=&quot;#QYLocalization&quot; class=&quot;headerlink&quot; title=&quot;QYLocalization&quot;&gt;&lt;/a&gt;QYLocalization&lt;/h2&gt;&lt;p&gt;最近接触到iOS应用本地化的相关使用，于是花
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>导航栏动画</title>
    <link href="http://yoursite.com/2015/11/03/%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2015/11/03/导航栏动画/</id>
    <published>2015-11-03T08:13:45.000Z</published>
    <updated>2018-04-08T08:40:48.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QYNavigationAnimation"><a href="#QYNavigationAnimation" class="headerlink" title="QYNavigationAnimation"></a>QYNavigationAnimation</h2><ul><li>The navigation bar to push the animation</li><li>导航栏推送动画</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>将QYNavigationAnimation文件导入项目中，使用QYNavigationAnimation创建导航栏控制器</li><li>为QYNavigationAnimation的导航栏对象设置QYNavigationAnimationModel属性，该属性为一个枚举类型:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, QYNavigationAnimationModel) &#123;</span><br><span class="line">    <span class="comment">// 往上push</span></span><br><span class="line">    QYNavigationUpPush,</span><br><span class="line">    <span class="comment">// 往左push</span></span><br><span class="line">    QYNavigationLeftPush,</span><br><span class="line">    <span class="comment">// 往右push</span></span><br><span class="line">    QYNavigationRightPush,</span><br><span class="line">    <span class="comment">// 往下push</span></span><br><span class="line">    QYNavigationDownPush,</span><br><span class="line">    <span class="comment">// 往左上push</span></span><br><span class="line">    QYNavigationLeftUpPush,</span><br><span class="line">    <span class="comment">// 往左下push</span></span><br><span class="line">    QYNavigationLeftDownPush,</span><br><span class="line">    <span class="comment">// 往右上push</span></span><br><span class="line">    QYNavigationRightUpPush,</span><br><span class="line">    <span class="comment">// 往右下push</span></span><br><span class="line">    QYNavigationRightDownPush</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>效果如下：</li></ul><p><img src="https://github.com/peanutNote/QYNavigationAnimation/blob/master/QYNavigationAnimation/demo.gif" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QYNavigationAnimation&quot;&gt;&lt;a href=&quot;#QYNavigationAnimation&quot; class=&quot;headerlink&quot; title=&quot;QYNavigationAnimation&quot;&gt;&lt;/a&gt;QYNavigationAnimation&lt;/
      
    
    </summary>
    
    
  </entry>
  
</feed>
